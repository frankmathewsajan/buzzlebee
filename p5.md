# Fractal Tree p5.js Implementation Guide

Purpose: This document reverse-engineers the existing fractal tree animation in `FractalTree.jsx` and provides a structured, parameterized specification so another developer—or an LLM (e.g. Claude Sonnet 4)—can reproduce, extend, or optimize it.

---
## 1. Original Implementation (Summary)
Source component: `src/components/FractalTree.jsx`
Key pieces:
- Uses `react-p5-wrapper` (`ReactP5Wrapper`) to mount a p5 sketch into React.
- Fixed 400×400 canvas.
- Angle dynamically animated each frame: `angle = map(sin(frameCount * 0.01), -1, 1, PI/2, PI/16)`.
- Recursive `branch(len)` draws a vertical line then translates upward, spawning two rotated sub-branches (binary tree) until `len <= 4`.
- No randomization: deterministic for a given frame.
- Uses `p5.clear()` each frame (alpha cleared) so there is no afterimage.
- Stroke color constant: white (`255`).

Minimal recursion logic (pseudo):
```
branch(len):
  line(0,0,0,-len)
  translate(0,-len)
  if len > 4:
    push(); rotate(+angle); branch(len*0.67); pop();
    push(); rotate(-angle); branch(len*0.67); pop();
```

---
## 2. Execution Lifecycle (p5 Sketch Contract)
A `ReactP5Wrapper` sketch must define (optionally) these lifecycle hooks as properties on the function scope using the `p5` instance:
- `p5.setup` – one-time init (canvas creation, static config).
- `p5.draw` – per-frame logic (animation, clearing, rendering).
- Optional: `p5.windowResized`, `p5.mousePressed`, etc.

Your sketch function receives a **single p5 instance**. State can be captured via closure variables or attached to `p5`.

---
## 3. Data & Parameters (Current vs. Generalized)
| Concept | Current | Potential Parameter | Notes |
|--------|---------|---------------------|-------|
| Initial length | 100 | `rootLength` | Controls scale. Responsive formula recommended. |
| Scale factor | 0.67 | `shrinkFactor` | <1 to converge; typical range 0.55–0.75. |
| Branching factor | 2 | `branching` (int) | Could add >2 via a loop of angles. |
| Angle base | Animated via sine | `angleFunction(frame)` | Allows noise, easing, interactive control. |
| Termination | `len > 4` | `minLength` | Could also base on recursion depth. |
| Stroke | Constant white | `strokeProvider(depth,len)` | Gradient, seasonal colors, alpha fade. |
| Canvas size | 400 × 400 | Responsive (parent width) | Accept via props or measure parent. |
| Background | Fully cleared | Layered fade (alpha rect) | Produces trailing effect. |
| Animation speed | 0.01 multiplier | `speed` | Adjust pacing of angle modulation. |
| Symmetry | Perfect | Introduce jitter | Organic feel. |

---
## 4. Parameterization Blueprint
To make the sketch configurable via React props, we can pattern:
```
<FractalTree
  width={500}
  height={500}
  rootLength={120}
  shrinkFactor={0.68}
  minLength={5}
  speed={0.012}
  angleMode="sin"   // or 'noise' | 'static'
  staticAngle={Math.PI/4}
  colorMode="depth-gradient" // or 'solid'
  branchJitter={0.05}
/>
```
`ReactP5Wrapper` can pass a `...props` object as the **second argument** to the sketch (depends on version). If unsupported, wrap state in a ref and rebuild wrapper when props change.

Sketch signature (new style):
```
const Sketch = (p5) => { ... } // base
// or
const Sketch = (p5) => (props?) // if wrapper version supports it
```
Check your installed `react-p5-wrapper` docs (v3+ uses `sketch={Sketch}` and supports `props`).

---
## 5. Enhanced Sketch (Illustrative Reference)
Below is a conceptual, *not yet in repo*, expanded form emphasizing pluggable behaviors. (An LLM can generate final code from this spec.)
```
function createFractalTreeSketch(config) {
  const {
    width, height,
    rootLength, shrinkFactor, minLength,
    angleMode, staticAngle, speed,
    colorMode, branchJitter,
    backgroundFade, noiseScale
  } = config;

  let angle = 0;
  let frame = 0;

  return function sketch(p5) {
    p5.setup = () => {
      p5.createCanvas(width, height);
      p5.strokeCap(p5.SQUARE);
    };

    p5.draw = () => {
      frame++;
      if (backgroundFade == null) { p5.clear(); }
      else {
        p5.noStroke();
        p5.fill(0, backgroundFade); // low alpha rectangle fade
        p5.rect(0,0,width,height);
      }

      angle = computeAngle(p5, angleMode, frame, speed, staticAngle, noiseScale);
      p5.push();
      p5.translate(width/2, height);
      branch(rootLength, 0);
      p5.pop();
    };

    function branch(len, depth) {
      styleStroke(depth, len);
      p5.line(0,0,0,-len);
      p5.translate(0,-len);
      if (len <= minLength) return;
      const baseAngle = angle;
      const jitter = branchJitter ? (p5.random(-branchJitter, branchJitter)) : 0;
      p5.push();
      p5.rotate(baseAngle + jitter);
      branch(len * shrinkFactor, depth+1);
      p5.pop();
      p5.push();
      p5.rotate(-baseAngle + jitter);
      branch(len * shrinkFactor, depth+1);
      p5.pop();
    }

    function styleStroke(depth, len) {
      if (colorMode === 'depth-gradient') {
        const t = Math.min(1, depth / 10);
        p5.stroke( lerpColorComp(200, 20, t), lerpColorComp(255, 120, t), lerpColorComp(255, 50, t), 255 );
        p5.strokeWeight(Math.max(1, len * 0.07));
      } else {
        p5.stroke(255);
        p5.strokeWeight(Math.max(1, len * 0.06));
      }
    }

    function lerpColorComp(a,b,t){ return a + (b-a)*t; }

    function computeAngle(p5, mode, frame, speed, staticAngle, noiseScale) {
      switch(mode) {
        case 'sin': return p5.map(p5.sin(frame * speed), -1, 1, p5.PI/2, p5.PI/16);
        case 'static': return staticAngle;
        case 'noise': return p5.map(p5.noise(frame * (noiseScale||0.01)), 0, 1, p5.PI/16, p5.PI/2);
        default: return p5.PI/4;
      }
    }
  };
}
```

---
## 6. Extension Ideas (Improvement Matrix)
| Goal | Technique | Notes |
|------|-----------|-------|
| Organic motion | Perlin `noise()` for angle & length jitter | Smoother than `sin` oscillation. |
| Seasonal colors | Gradient by depth & time | Map depth to hue; animate hue shift. |
| Wind effect | Add small `sin(frame*windSpeed + depth)` rotation offset | Increases realism. |
| 3D tree | Use p5 WEBGL, vary branch rotation Z/Y | More immersive; complexity + cost. |
| Interaction | Mouse X controls max angle | Enhances engagement. |
| Performance | Iterative stack instead of recursion | Helps avoid deep recursion for large trees. |
| Growth animation | Increase `rootLength` gradually | Simulate tree growing over time. |
| Save frames / GIF | Use `p5.saveCanvas` or external capture | For sharing. |
| Multi-tree forest | Loop multiple seeds across width | Random seed per tree. |
| Branch thickness taper | `strokeWeight(len * factor)` | Enhances tree shape. |

---
## 7. Performance Considerations
- Depth explodes geometrically: effective complexity O(2^d) where d ~ log(baseLength/minLength). Keep `shrinkFactor` modest.
- Use `p5.frameRate(30)` if CPU heavy; or throttle re-render (only redraw every N frames).
- Avoid generating new objects in hot loops (reuse computations where possible).
- For large canvases, pre-render static background or static trunk layers to a `p5.Graphics` buffer.

---
## 8. React Integration Patterns
### A. Direct (Current Approach)
```
<ReactP5Wrapper sketch={Sketch} />
```
Re-mount occurs if `Sketch` identity changes. To update parameters live, pass a stable sketch and (if supported) pass a `props` object: 
```
<ReactP5Wrapper sketch={Sketch} rootLength={150} shrinkFactor={0.65} />
```
Inside sketch: read via `p5.updateWithProps = (props) => { ... }`.

### B. Conditional Hydration
If tree is off-screen initially, lazily render component when scrolled into view (e.g. `IntersectionObserver`) to save CPU.

---
## 9. Example With Prop Updates (`updateWithProps` Pattern)
```
const Sketch = (p5) => {
  let angle = 0;
  let cfg = { rootLength: 100, shrink: 0.67 };

  p5.updateWithProps = (props) => {
    if (props.rootLength) cfg.rootLength = props.rootLength;
    if (props.shrink) cfg.shrink = props.shrink;
  };

  p5.setup = () => p5.createCanvas(400,400);
  p5.draw = () => {
    p5.clear();
    angle = p5.map(p5.sin(p5.frameCount*0.01), -1,1, p5.PI/2, p5.PI/16);
    p5.push(); p5.translate(200, p5.height); branch(cfg.rootLength); p5.pop();
  };
  function branch(len){
    p5.line(0,0,0,-len); p5.translate(0,-len);
    if(len>4){
      p5.push(); p5.rotate(angle); branch(len*cfg.shrink); p5.pop();
      p5.push(); p5.rotate(-angle); branch(len*cfg.shrink); p5.pop();
    }
  }
};
```

React usage:
```
<ReactP5Wrapper sketch={Sketch} rootLength={140} shrink={0.62} />
```

---
## 10. Migration to React 17+/18 Notes
- Ensure `react-p5-wrapper` version matches React peer requirements. If upgrading React, reinstall to align.
- No changes needed inside the sketch for JSX runtime differences.

---
## 11. Validation Checklist (For LLM Output)
When asking an LLM to produce or extend the sketch, instruct it to:
1. Respect provided configuration interface (list parameters explicitly).
2. Avoid infinite recursion (enforce termination condition).
3. Keep per-frame mutations isolated (use `push()` / `pop()` correctly).
4. Ensure canvas is cleared or intentionally blended (decide effect style before coding).
5. Provide deterministic seeding if reproducibility required (p5 `randomSeed`).
6. Use `updateWithProps` for live React-driven parameter changes (if using react-p5-wrapper v3+).
7. Optimize to not allocate large arrays or objects inside recursion loops.
8. Include comments mapping each configurable parameter to its visual effect.

---
## 12. Prompt Template for an LLM (Editable)
```
You are generating a p5.js fractal tree sketch to embed via react-p5-wrapper. Requirements:
- Configurable: width, height, rootLength, shrinkFactor, minLength, angleMode(sin|noise|static), staticAngle, speed, colorMode(solid|depth-gradient), branchJitter, backgroundFade.
- Use updateWithProps to react to prop changes.
- Performance: recursion depth limited; no excessive allocations.
- Provide exportable React component <FractalTree ...props />.
Return a single file solution with explanatory comments.
```

---
## 13. Troubleshooting
| Symptom | Cause | Fix |
|---------|-------|-----|
| Blank canvas | Canvas appended under hidden parent | Ensure parent visible or delay setup. |
| Max call stack | Termination condition too loose (minLength too small, shrinkFactor ~1) | Increase `minLength` or reduce `shrinkFactor`. |
| Stutters | Too many branches / high frame rate | Lower rootLength or frame rate; throttle angle updates. |
| Angle not updating | Forgot to recompute each frame | Move angle calc into `draw`. |

---
## 14. Future Directions
- Generate L-systems grammar trees for varied species.
- Add seasonal transitions by interpolating color palettes across time.
- Export to SVG for print (line-based rendering instead of canvas).
- Add UI panel (e.g., Zustand + controlled sliders) for real-time parameter tuning.
- Multi-pass render: glow effect using blurred off-screen buffer.

---
## 15. Minimal vs. Extended Comparison
| Version | Lines (approx) | Features |
|---------|----------------|----------|
| Original | ~30 | Binary fractal, sine angle. |
| Parameterized Basic | ~60 | Configurable length/angle/shrink. |
| Advanced | 100–150 | Noise, gradients, jitter, fade trails, live props. |

Strive to scale complexity only when it delivers visible value.

---
## 16. Actionable Starting Point (Concise Base Spec)
Baseline spec for regeneration:
```
rootLength: 100
shrinkFactor: 0.67
minLength: 4
angleMode: sin (map sin to [PI/2, PI/16])
speed: 0.01
canvas: square, centered tree (translate width/2, height)
clear each frame
white stroke, strokeWeight proportional to current branch length (optional improvement)
```

---
## 17. License / Attribution Considerations
- Original code is simple; treat extension as original work unless existing repo has a license file dictating otherwise.
- If using palettes or algorithm variants from academic sources (e.g., L-systems), cite them in comments.

---
## 18. Quick Quality Gate (What to Verify After Implementing)
- Canvas mounts correctly inside layout.
- No console errors (especially React prop updates, missing libs).
- Adjusting props live changes output without remount flicker.
- CPU usage acceptable (< ~5–10% on typical hardware for one instance).

---
## 19. Summary
The fractal tree relies on a classic symmetric recursive drawing with a time-varying angle. By abstracting its numeric constants into parameters and organizing extension hooks (angle functions, coloring, jitter, fade), it can evolve into a rich procedural art system while retaining the clarity and minimalism of the original implementation.

Use this document as a blueprint to: (a) regenerate the original effect, (b) systematically add features, or (c) guide an LLM to produce production-ready, parameter-driven code.
